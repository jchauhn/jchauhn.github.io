<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=443&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data exfiltration via DNS | jc's blog</title>
<meta name=keywords content="docker,dns,wireshark"><meta name=description content="Exfiltrating data using specially crafted DNS packets"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.705b335eef705bb62a61006cbb665098e195fe597d88ac22db7bb87220664e4b.css integrity="sha256-cFszXu9wW7YqYQBsu2ZQmOGV/ll9iKwi23u4ciBmTks=" rel="preload stylesheet" as=style><link rel=icon href=https://jchauhn.github.io:443/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jchauhn.github.io:443/favicon1616.ico><link rel=icon type=image/png sizes=32x32 href=https://jchauhn.github.io:443/favicon3232.ico><link rel=apple-touch-icon href=https://jchauhn.github.io:443/apple-touch-icon.png><link rel=mask-icon href=https://jchauhn.github.io:443/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jchauhn.github.io:443/assignments/dnsexfil/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jchauhn.github.io:443/assignments/dnsexfil/"><meta property="og:site_name" content="jc's blog"><meta property="og:title" content="Data exfiltration via DNS"><meta property="og:description" content="Exfiltrating data using specially crafted DNS packets"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="assignments"><meta property="article:published_time" content="2025-10-10T11:30:03+00:00"><meta property="article:modified_time" content="2025-10-10T11:30:03+00:00"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Dns"><meta property="article:tag" content="Wireshark"><meta property="og:image" content="https://jchauhn.github.io:443/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jchauhn.github.io:443/%3Cimage%20path/url%3E"><meta name=twitter:title content="Data exfiltration via DNS"><meta name=twitter:description content="Exfiltrating data using specially crafted DNS packets"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Assignments","item":"https://jchauhn.github.io:443/assignments/"},{"@type":"ListItem","position":2,"name":"Data exfiltration via DNS","item":"https://jchauhn.github.io:443/assignments/dnsexfil/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Data exfiltration via DNS","name":"Data exfiltration via DNS","description":"Exfiltrating data using specially crafted DNS packets","keywords":["docker","dns","wireshark"],"articleBody":"This HW delves into the fundamentals of network packets and DNS. DNS, or Domain Name Service, is the phonebook of the internet. It is used to resolve human-readable URLs into IP address of servers/machines. While this is the intended use of DNS, it can be abused for other purposes. This week, you will assume the role of an attacker who has compromised a client system and needs to extract files to an attacker-controlled server via DNS requests and responses. This is an actual technique used by attackers, including APT (Advanced Persistent Threat) groups such as the OilRig, to extract data from sensitive environments.\nThis HW will teach you about DNS resolvers and creating raw packets using the Python scapy module. You will then use your knowledge of DNS packets and their format to build a custom DNS exfiltration tool.\nDUE DATE: Oct 28, 2025 11:59pm Task 1: Set up a simple dnsmasq instance and capture the request You need to create a new docker-compose.yml. This will orchestrate 2 containers built from Dockerfile.client (this is provided) and Dockerfile.dns (this you need to create). On Dockerfile.dns, you will need to set up a working dnsmasq instance that listens for DNS requests on UDP port 53. You need to figure out how to install dnsmasq (on a Docker container) and configure it (using /etc/dnsmasq.conf).\nTo verify, you will need to query the DNS records of the domain cs.uic.edu via nslookup/dig (the query happens on Dockerfile.client) and capture the network traffic in basic-dns.pcap (the capture happens on Dockerfile.dns).\nNote:\nDo not modify the container/image names or the subnet or the IP/MAC addresses in the docker-compose.yml. Dockerfile.client needs to have the IP address 172.28.10.12 Dockerfile.dns needs to have the IP address 172.28.10.2. You will also need to force Dockerfile.client to use Dockerfile.dns as the DNS resolver instead of Docker’s default resolver. This can be achieved via docker-compose or command line switches in nslookup/dig. Task 2: Build the exfiltrate.py and listener.py files You will create a DNS data exfiltrator in a file /exfiltrate.py (this will execute on Dockerfile.client). This Python script will read /secret.txt from the Dockerfile.client and use the scapy Python module to exfiltrate it via DNS packets. To receive the packets on the other end, you will also need to create a corresponding /listener.py (run on Dockerfile.dns) that will listen on UDP port 53 for the DNS packets, extract the data using the scapy module, and rebuild /secret.txt. It is important to note that you will have to work within the constraints of DNS packets (such as size, encoding, etc.) when transmitting data. This means that you will have to break the secret into smaller pieces and send each piece in its own DNS packet.\nA typical DNS query packet sent over UDP has a maximum size of 512 bytes. This allows for roughly 255 bytes of usable space per packet. You will utilize base64 to encode the secret.txt before breaking it up and sending it over DNS. The secret.txt given with the HW, after it is base64 encoded, is around 1700 bytes long. The /listener.py will decode the base64 and rebuild the secret in the correct order.\nIt is necessary that the secret is rebuilt in the correct order to receive full credit. This can be achieved by ordering the DNS queries using Transaction IDs (TxIDs). The secret.txt should be encoded in a linear fashion using transaction IDs low to high. E.g. the DNS packets containing the first few bytes of secret.txt can have a TxID of 0x001, next few with a TxID of 0x002 and so on. The exact TxID don’t matter but the order must be ascending. On the decryption end, listener.py will order the packets in ascending order using TxIDs before decoding it.\nProgram should work for any number of Unicode characters in secret.txt. That is, the program should be able to send and rebuild secret.txt of any length as long as it contains Unicode characters. You can safely assume that the length of secret will not exceed the maximum number of unique TxIDs.\nTo verify, you will need to capture the packets sent by the client in exfil-dns.pcap (the capture happens on Dockerfile.dns). Ensure that the capture runs long enough to capture secret.txt given with the homework.\nNote:\nAll .py files need to run in the root directory of their respective container. DNS packets use UDP, which can be unsynchronized and lossy. While this is unlikely to happen in an ideal Docker environment, don’t worry about building error correction mechanisms in the data transfer. As long as the tool can transfer the secret and reassemble it in the correct order, you will receive full credit. Use a non existent domain doesnotexist.com as a base for all queries to ensure you don’t impact an actual non-root DNS server. Hint: DNS responses are supposed to return either domain names or IP addresses, but can they be used to send something else? How would you hide data in domain URLs? Check out the helpful reading section.\nDeliverables: basic-dns.pcap dnsmasq.conf Dockerfile.dns exfil-dns.pcap exfiltrate.py which is run on Dockerfile.client (you don’t need to send Dockerfile.client) listener.py which is run on Dockerfile.dns Helpful readings. Data Exfiltration Over DNS, HTTP \u0026 Custom Covert Channels What Is DNS Data Exfiltration What is DNS Tunnelingor T9: arp-attack.pcap. (Clarification: also capture on Dockerfile.client) ","wordCount":"884","inLanguage":"en","image":"https://jchauhn.github.io:443/%3Cimage%20path/url%3E","datePublished":"2025-10-10T11:30:03Z","dateModified":"2025-10-10T11:30:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jchauhn.github.io:443/assignments/dnsexfil/"},"publisher":{"@type":"Organization","name":"jc's blog","logo":{"@type":"ImageObject","url":"https://jchauhn.github.io:443/favicon.ico"}}}</script></head><body id=top><link rel=stylesheet href=/css/extended/chroma.css><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><br></nav></header><div class=layout-with-left-panel><div class=left-panel><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><div id=left-panel><h1>jc's blog</h1><p class=infoblob>Collection of personal ideas & arcane reseach</p><a class=corelink href=/posts>Posts</a>
<a class=corelink href=/>About</a>
<a class=corelink href=https://www.linkedin.com/in/jchauhn/>Contact</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></div><main class=main><div class=content-area><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Data exfiltration via DNS</h1><div class=post-description>Exfiltrating data using specially crafted DNS packets</div><div class=post-meta><span title='2025-10-10 11:30:03 +0000 +0000'>October 10, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;884 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/assignments/dnsexfil.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://jchauhn.github.io:443/%3Cimage%20path/url%3E alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#task-1-set-up-a-simple-dnsmasq-instance-and-capture-the-request>Task 1: Set up a simple <code>dnsmasq</code> instance and capture the request</a></li><li><a href=#task-2-build-the-exfiltratepy-and-listenerpy-files>Task 2: Build the <code>exfiltrate.py</code> and <code>listener.py</code> files</a></li><li><a href=#deliverables>Deliverables:</a><ul><li></li></ul></li></ul></nav></div></details></div><div class=post-content><p>This HW delves into the fundamentals of network packets and DNS. DNS, or Domain
Name Service, is the phonebook of the internet. It is used to resolve
human-readable URLs into IP address of servers/machines. While this is
the intended use of DNS, it can be abused for other purposes.
This week, you will assume the role of an attacker who has compromised a
client system and needs to extract files to an attacker-controlled server via
DNS requests and responses. This is an actual technique used by attackers,
including APT (Advanced Persistent Threat) groups such as the
<a href=https://malpedia.caad.fkie.fraunhofer.de/actor/oilrig>OilRig</a>, to extract
data from sensitive environments.</p><p>This HW will teach you about DNS resolvers and creating raw packets using the
Python <code>scapy</code> module. You will then use your knowledge of DNS packets and
their format to build a custom DNS exfiltration tool.</p><h4 id=due-date-oct-28-2025-1159pm>DUE DATE: Oct 28, 2025 11:59pm<a hidden class=anchor aria-hidden=true href=#due-date-oct-28-2025-1159pm>#</a></h4><h2 id=task-1-set-up-a-simple-dnsmasq-instance-and-capture-the-request>Task 1: Set up a simple <code>dnsmasq</code> instance and capture the request<a hidden class=anchor aria-hidden=true href=#task-1-set-up-a-simple-dnsmasq-instance-and-capture-the-request>#</a></h2><p>You need to create a new <code>docker-compose.yml</code>. This will orchestrate 2
containers built from <code>Dockerfile.client</code> (this is provided) and <code>Dockerfile.dns</code> (this you need to
create). On <code>Dockerfile.dns</code>, you will need to set up a working
<a href=https://help.ubuntu.com/community/Dnsmasq><code>dnsmasq</code></a> instance that listens
for DNS requests on UDP port 53. You need to figure out how to install
<code>dnsmasq</code> (on a Docker container) and configure it (using <code>/etc/dnsmasq.conf</code>).</p><p>To verify, you will need to query the DNS records of the domain <code>cs.uic.edu</code>
via <code>nslookup</code>/<code>dig</code> (the query happens on <code>Dockerfile.client</code>) and capture the
network traffic in <code>basic-dns.pcap</code> (the capture happens on <code>Dockerfile.dns</code>).</p><p>Note:</p><ul><li>Do not modify the container/image names or the subnet or the IP/MAC addresses
in the <code>docker-compose.yml</code>.</li><li><code>Dockerfile.client</code> needs to have the IP address 172.28.10.12</li><li><code>Dockerfile.dns</code> needs to have the IP address 172.28.10.2.</li><li>You will also need to force <code>Dockerfile.client</code> to use <code>Dockerfile.dns</code> as
the DNS resolver instead of Docker&rsquo;s default resolver. This can be achieved
via docker-compose or command line switches in <code>nslookup</code>/<code>dig</code>.</li></ul><h2 id=task-2-build-the-exfiltratepy-and-listenerpy-files>Task 2: Build the <code>exfiltrate.py</code> and <code>listener.py</code> files<a hidden class=anchor aria-hidden=true href=#task-2-build-the-exfiltratepy-and-listenerpy-files>#</a></h2><p>You will create a DNS data exfiltrator in a file <code>/exfiltrate.py</code> (this will execute
on <code>Dockerfile.client</code>). This Python script will read <code>/secret.txt</code> from the
<code>Dockerfile.client</code> and use the <code>scapy</code> Python module to exfiltrate it via DNS
packets. To receive the packets on the other end, you will also need to create
a corresponding <code>/listener.py</code> (run on <code>Dockerfile.dns</code>) that will listen on
UDP port 53 for the DNS packets, extract the data using the <code>scapy</code> module, and
rebuild <code>/secret.txt</code>. It is important to note that you will have to work
within the constraints of DNS packets (such as size, encoding, etc.) when
transmitting data. This means that you will have to break the secret into
smaller pieces and send each piece in its own DNS packet.</p><p>A typical DNS query packet sent over UDP has a maximum size of 512 bytes. This
allows for roughly 255 bytes of usable space per packet. You will utilize <code>base64</code> to
encode the <code>secret.txt</code> before breaking it up and sending it over DNS.
The <code>secret.txt</code> given with the HW, after it is base64 encoded, is around 1700 bytes long. The
<code>/listener.py</code> will decode the <code>base64</code> and rebuild the secret in the correct
order.</p><p>It is necessary that the secret is rebuilt in the correct order to receive full
credit. This can be achieved by ordering the DNS queries using Transaction IDs (TxIDs).
The <code>secret.txt</code> should be encoded in a linear fashion using transaction IDs low to high.
E.g. the DNS packets containing
the first few bytes of <code>secret.txt</code> can have a TxID of 0x001, next few with a TxID
of 0x002 and so on. The exact TxID don&rsquo;t matter but the order must be ascending.
On the decryption end, <code>listener.py</code> will order the packets in ascending order
using TxIDs before decoding it.</p><p>Program should work for any number of Unicode characters in <code>secret.txt</code>.
That is, the program should be able to send and rebuild <code>secret.txt</code> of any length
as long as it contains Unicode characters. You can safely assume that the length of secret
will not exceed the maximum number of unique TxIDs.</p><p>To verify, you will need to capture the packets sent by the client in
<code>exfil-dns.pcap</code> (the capture happens on <code>Dockerfile.dns</code>). Ensure that the
capture runs long enough to capture <code>secret.txt</code> given with the homework.</p><p>Note:</p><ul><li>All <code>.py</code> files need to run in the root directory of their respective
container.</li><li>DNS packets use UDP, which can be unsynchronized and lossy. While this is
unlikely to happen in an ideal Docker environment, don&rsquo;t worry about building
error correction mechanisms in the data transfer. As long as the tool can
transfer the secret and reassemble it in the correct order, you will receive
full credit.</li><li>Use a non existent domain <code>doesnotexist.com</code> as a base for all queries to ensure
you don&rsquo;t impact an actual non-root DNS server.</li></ul><p>Hint: DNS responses are supposed to return either domain names or IP addresses,
but can they be used to send something else? How would you hide data in domain
URLs? Check out the helpful reading section.</p><h2 id=deliverables>Deliverables:<a hidden class=anchor aria-hidden=true href=#deliverables>#</a></h2><ul><li><strong>basic-dns.pcap</strong></li><li><strong>dnsmasq.conf</strong></li><li><strong>Dockerfile.dns</strong></li><li><strong>exfil-dns.pcap</strong></li><li><strong>exfiltrate.py</strong> which is run on <code>Dockerfile.client</code> (you don&rsquo;t need to send
<code>Dockerfile.client</code>)</li><li><strong>listener.py</strong> which is run on <code>Dockerfile.dns</code></li></ul><h4 id=helpful-readings>Helpful readings.<a hidden class=anchor aria-hidden=true href=#helpful-readings>#</a></h4><ul><li><a href=https://cyberw1ng.medium.com/data-exfiltration-over-dns-http-custom-covert-channels-646d63562c01>Data Exfiltration Over DNS, HTTP & Custom Covert
Channels</a></li><li><a href=https://www.akamai.com/glossary/what-is-dns-data-exfiltration>What Is DNS Data
Exfiltration</a></li><li><a href=https://www.paloaltonetworks.ca/cyberpedia/what-is-dns-tunneling>What is DNS
Tunneling</a>or T9: <strong>arp-attack.pcap</strong>.  (Clarification: also capture on Dockerfile.client)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jchauhn.github.io:443/tags/docker/>Docker</a></li><li><a href=https://jchauhn.github.io:443/tags/dns/>Dns</a></li><li><a href=https://jchauhn.github.io:443/tags/wireshark/>Wireshark</a></li></ul></footer></article></div></main></div><footer class=footer><span>&copy; 2026 <a href=https://jchauhn.github.io:443/>jc's blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>