<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=443&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Paper USENIX | jc's blog</title>
<meta name=keywords content><meta name=description content="Paper"><meta name=author content="Me"><link rel=canonical href=https://jchauhn.github.io:443/posts/hidden/paper_backup/><link crossorigin=anonymous href=/assets/css/stylesheet.580b14abcdff654725dca950fc193a94af9a059724b1c7face549d539b70bd7d.css integrity="sha256-WAsUq83/ZUcl3KlQ/Bk6lK+aBZckscf6zlSdU5twvX0=" rel="preload stylesheet" as=style><link rel=icon href=https://jchauhn.github.io:443/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jchauhn.github.io:443/favicon1616.ico><link rel=icon type=image/png sizes=32x32 href=https://jchauhn.github.io:443/favicon3232.ico><link rel=apple-touch-icon href=https://jchauhn.github.io:443/apple-touch-icon.png><link rel=mask-icon href=https://jchauhn.github.io:443/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jchauhn.github.io:443/posts/hidden/paper_backup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://jchauhn.github.io:443/posts/hidden/paper_backup/"><meta property="og:site_name" content="jc's blog"><meta property="og:title" content="Paper USENIX"><meta property="og:description" content="Paper"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-09T11:30:03+00:00"><meta property="article:modified_time" content="2025-06-09T11:30:03+00:00"><meta property="og:image" content="https://jchauhn.github.io:443/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jchauhn.github.io:443/%3Cimage%20path/url%3E"><meta name=twitter:title content="Paper USENIX"><meta name=twitter:description content="Paper"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jchauhn.github.io:443/posts/"},{"@type":"ListItem","position":2,"name":"Paper USENIX","item":"https://jchauhn.github.io:443/posts/hidden/paper_backup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Paper USENIX","name":"Paper USENIX","description":"Paper","keywords":[],"articleBody":"1. Experiment Design Most of the sensitive PIIs in MacOS for the user are exposed to application via operating system APIs. The crux of the experiment revolves around intercepting sensitive APIs to understand which component of the application actually requested the data in question.\nIntercepting these APIs involves runtime modification of the binary via Frida. Frida is open source reverse engineering framework primarily designed for iPhone and Android. Frida allows us to “hook” function calls i.e. it allows us to control the behavior of the instruction pointer both before and after a function from the binary symbol table is called. Frida allows for this manipulation via its functions “onEnter” and “onLeave”.\nBy adding conditionals and logging statements to these onEnter and onLeave for a variey of known senstive MacOS APIs, we gain insight into the Apps behvaior intended or otherwise.\n1.1 Hooking APIs The first step is building a list of sentive MacOS APIs. This is no small feat given the breadth and the depth of the Darwin arch. We build this repository of MacOS APIs by manully crawling Apple’s Documentation and their public archives. We then manually test these APIs to confirm the sensitive nature of the returned information.\nOn this note, we have built a executable which are the queries these APIs to build a system fingerprinting report.\nWe intercept MacOS APIs via Frida’s python bindings. We modify the onEnter for the collected APIs and then log the Backtrace and the frequency of API calls. The Backtrace is the call track trace of the system when the call was made i.e it catures all the parent functions which led to the particular call. This nacktrace is is fuzzy, i,e it attributes to the underlying binary/dynamic library which led to the call. This allows us to understand whether first party code or included libraries led to the snesitive API call.\n1.2 Network Interception Another component of the dynamic analysis is the MiTM netork intercetion via mitmproxy. We capture all the HTTP(S) and DNS requests. We attempt to extract any identifiers being sent and we also track the connection made to known ad domains.\n###:w 1.3 Simulated Interaction\nOne of our unique controbutions to this research is AI driven interaction which utilizes the MacOS’s Accessiblity Framework to interact witht he application intelligently. We capture the app window data via the Accessiblity Framework and forward it OpenAI’s API. The ML models interacts with the application using a fixed framework of object clicks and keyboard inputs interpreted via the MCP model. The modifed an new repository macos-Use to allow for almost completly autonomous interaction. The only challanege are signup screen and email verification which were non-trivial to bypass. Hence, the autonomous interaction begins once the app is signed it or shows a dashboard.\n2. Prior Work 3. Results TLDR Build During the build process of the application the developer has to go over several hoops.\nApple Docs Apple has extensive developer documentation which covers a wide range of topic from low level data structures and kernel primitives to permission, to privacy best practices to app Store guidelines. While this knowledge base is extensive, it is not complete.\nApple also has legacy archived documentation which covers APIs inherited from BSD legacy OS. Additonaly, the guidelines are spread accross documentation, press releases and developer notes.\nThe biggest challenge for a fresh developer is the sheer scale of knowledge required to make a perfectly compliant application. Obtuse, confusing and often contradictory defintions of key terms such as tracking and PIIs don’t help.\nCode Knowledge Code knowledge refers to a developer’s understanding of the code included in the application. This includes both the 1st Party Code and 3rd Party Code.\n3rd Party Code is typically included in the application via libaries or framework modules which can then called by the Application for a particular purpose. Given some of the most popular frameworks are created by tech giants like Meta and Google, the developer has little transparency and consequently understanding of the undelying logic. Thus is very tough for developer to gauge the privacy implications of the included code on the overall application.\nFirst code is code written by the developer themselves. While it stands to reason that a developer should understand the code they write, this assumotion is becoming increasingly fraught with the rise of “Vibe-Coding”, and AI coding agents. Developer are increasingly shrugging of the details of code to LLMs which are non deterministic and thus can prone to faultly behavior. Thus first party code can include calls to unintended APIs without the developers knowledge provided the developer doesn’t completly check the LLM produced code.\nSubmission When the developer submits their application to the App Store Connect for inclusion in the App Store, they need to provide\nPrivacy Manifest Nutrition Lables. Privacy Manifest covers a list of fingerprintable APIs which can be used for tracking a user based on their device charecteristics. Apple has a defined a list of restricted APIs which they say can be used for fingerprinting. These APIs pertain to disk charecteristics such as free disk spaces or file descriptions and mount information. Some of the other APIs pertain to the time since boot which can be a good fingerprint.\n3rd Party Docs 3rd Party Manifest Files Runtime ","wordCount":"876","inLanguage":"en","image":"https://jchauhn.github.io:443/%3Cimage%20path/url%3E","datePublished":"2025-06-09T11:30:03Z","dateModified":"2025-06-09T11:30:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jchauhn.github.io:443/posts/hidden/paper_backup/"},"publisher":{"@type":"Organization","name":"jc's blog","logo":{"@type":"ImageObject","url":"https://jchauhn.github.io:443/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><br></nav></header><div class=layout-with-left-panel><div class=left-panel><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><div id=left-panel><h1>jc's blog</h1><p class=infoblob>Collection of personal ideas & arcane reseach</p><a class=corelink href=/posts>Posts</a>
<a class=corelink href=/>About</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></div><main class=main><div class=content-area><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Paper USENIX</h1><div class=post-description>Paper</div><div class=post-meta><span title='2025-06-09 11:30:03 +0000 +0000'>June 9, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;876 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/hidden/paper_backup.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://jchauhn.github.io:443/%3Cimage%20path/url%3E alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#11-hooking-apis>1.1 Hooking APIs</a></li><li><a href=#12-network-interception>1.2 Network Interception</a></li></ul></li></ul><ul><li><a href=#build>Build</a><ul><li><a href=#apple-docs>Apple Docs</a></li><li><a href=#code-knowledge>Code Knowledge</a></li></ul></li><li><a href=#submission>Submission</a><ul><li><a href=#3rd-party-docs>3rd Party Docs</a></li><li><a href=#3rd-party-manifest-files>3rd Party Manifest Files</a></li></ul></li><li><a href=#runtime>Runtime</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-experiment-design>1. Experiment Design<a hidden class=anchor aria-hidden=true href=#1-experiment-design>#</a></h1><p>Most of the sensitive PIIs in MacOS for the user are exposed to application via operating system APIs.
The crux of the experiment revolves around intercepting sensitive APIs to understand which component of the application actually requested the data in question.</p><p>Intercepting these APIs involves runtime modification of the binary via Frida. Frida is open source reverse engineering framework primarily designed for iPhone and Android. Frida allows us to &ldquo;hook&rdquo; function calls i.e. it allows us to control the behavior of the instruction pointer both before and after a function from the binary symbol table is called. Frida allows for this manipulation via its functions &ldquo;onEnter&rdquo; and &ldquo;onLeave&rdquo;.</p><p>By adding conditionals and logging statements to these onEnter and onLeave for a variey of known senstive MacOS APIs, we gain insight into the Apps behvaior intended or otherwise.</p><h3 id=11-hooking-apis>1.1 Hooking APIs<a hidden class=anchor aria-hidden=true href=#11-hooking-apis>#</a></h3><p>The first step is building a list of sentive MacOS APIs. This is no small feat given the breadth and the depth of the Darwin arch. We build this repository of MacOS APIs by manully crawling Apple&rsquo;s Documentation and their public archives. We then manually test these APIs to confirm the sensitive nature of the returned information.</p><p>On this note, we have built a executable which are the queries these APIs to build a system fingerprinting report.</p><p>We intercept MacOS APIs via Frida&rsquo;s python bindings. We modify the onEnter for the collected APIs and then log the Backtrace and the frequency of API calls. The Backtrace is the call track trace of the system when the call was made i.e it catures all the parent functions which led to the particular call. This nacktrace is is fuzzy, i,e it attributes to the underlying binary/dynamic library which led to the call. This allows us to understand whether first party code or included libraries led to the snesitive API call.</p><h3 id=12-network-interception>1.2 Network Interception<a hidden class=anchor aria-hidden=true href=#12-network-interception>#</a></h3><p>Another component of the dynamic analysis is the MiTM netork intercetion via mitmproxy. We capture all the HTTP(S) and DNS requests. We attempt to extract any identifiers being sent and we also track the connection made to known ad domains.</p><p>###:w
1.3 Simulated Interaction</p><p>One of our unique controbutions to this research is AI driven interaction which utilizes the MacOS&rsquo;s Accessiblity Framework to interact witht he application intelligently. We capture the app window data via the Accessiblity Framework and forward it OpenAI&rsquo;s API. The ML models interacts with the application using a fixed framework of object clicks and keyboard inputs interpreted via the MCP model. The modifed an new repository macos-Use to allow for almost completly autonomous interaction. The only challanege are signup screen and email verification which were non-trivial to bypass. Hence, the autonomous interaction begins once the app is signed it or shows a dashboard.</p><h1 id=2-prior-work>2. Prior Work<a hidden class=anchor aria-hidden=true href=#2-prior-work>#</a></h1><h1 id=3-results>3. Results<a hidden class=anchor aria-hidden=true href=#3-results>#</a></h1><h1 id=tldr>TLDR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h1><h2 id=build>Build<a hidden class=anchor aria-hidden=true href=#build>#</a></h2><p>During the build process of the application the developer has to go over several hoops.</p><h3 id=apple-docs>Apple Docs<a hidden class=anchor aria-hidden=true href=#apple-docs>#</a></h3><p>Apple has extensive developer documentation which covers a wide range of topic from low level data structures and kernel primitives to permission, to privacy best practices to app Store guidelines. While this knowledge base is extensive, it is not complete.</p><p>Apple also has legacy archived documentation which covers APIs inherited from BSD legacy OS.
Additonaly, the guidelines are spread accross documentation, press releases and developer notes.</p><p>The biggest challenge for a fresh developer is the sheer scale of knowledge required to make a perfectly compliant application.
Obtuse, confusing and often contradictory defintions of key terms such as tracking and PIIs don&rsquo;t help.</p><p><img alt="Alt text" loading=lazy src=/blog/images/build_journey.png></p><h3 id=code-knowledge>Code Knowledge<a hidden class=anchor aria-hidden=true href=#code-knowledge>#</a></h3><p>Code knowledge refers to a developer&rsquo;s understanding of the code included in the application.
This includes both the 1st Party Code and 3rd Party Code.</p><p>3rd Party Code is typically included in the application via libaries or framework modules which can then called by the Application for a particular purpose. Given some of the most popular frameworks are created by tech giants like Meta and Google, the developer has little transparency and consequently understanding of the undelying logic. Thus is very tough for developer to gauge the privacy implications of the included code on the overall application.</p><p>First code is code written by the developer themselves. While it stands to reason that a developer should understand the code they write, this assumotion is becoming increasingly fraught with the rise of &ldquo;Vibe-Coding&rdquo;, and AI coding agents. Developer are increasingly shrugging of the details of code to LLMs which are non deterministic and thus can prone to faultly behavior. Thus first party code can include calls to unintended APIs without the developers knowledge provided the developer doesn&rsquo;t completly check the LLM produced code.</p><h2 id=submission>Submission<a hidden class=anchor aria-hidden=true href=#submission>#</a></h2><p>When the developer submits their application to the App Store Connect for inclusion in the App Store, they need to provide</p><ul><li>Privacy Manifest</li><li>Nutrition Lables.</li></ul><p>Privacy Manifest covers a list of fingerprintable APIs which can be used for tracking a user based on their device charecteristics. Apple has a defined a list of restricted APIs which they say can be used for fingerprinting. These APIs pertain to disk charecteristics such as free disk spaces or file descriptions and mount information. Some of the other APIs pertain to the time since boot which can be a good fingerprint.</p><h3 id=3rd-party-docs>3rd Party Docs<a hidden class=anchor aria-hidden=true href=#3rd-party-docs>#</a></h3><h3 id=3rd-party-manifest-files>3rd Party Manifest Files<a hidden class=anchor aria-hidden=true href=#3rd-party-manifest-files>#</a></h3><h2 id=runtime>Runtime<a hidden class=anchor aria-hidden=true href=#runtime>#</a></h2></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jchauhn.github.io:443/posts/hidden/paper/><span class=title>« Prev</span><br><span>Paper MacOS Security</span>
</a><a class=next href=https://jchauhn.github.io:443/posts/tornadocash/><span class=title>Next »</span><br><span>Requim of TornadoCash</span></a></nav></footer></article></div></main></div><footer class=footer><span>&copy; 2026 <a href=https://jchauhn.github.io:443/>jc's blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>